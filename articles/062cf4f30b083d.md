---
title: "マインスイーパでオブジェクト指向の設計を学んだ"
emoji: "💣"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに
オブジェクト指向の学び方について悩んだことはありませんか？

設計の本を読んでもイマイチ腹に落ちない感覚を私は何度も味わってきました。

本記事では、「マインスイーパ」を題材としてオブジェクト指向の設計についてアウトプットします。私はこの設計を通じてオブジェクト指向がチョットワカルになったので是非最後まで読んでいただけると嬉しいです。

https://github.com/Yuhi-Sato/minesweeper
サンプルコードはこちらです

# 対象読者
- オブジェクト指向を学びたい方
- 設計の技術書を1冊読んだことがある方
- デザインパターンを学びたい方
- （番外編にて）Rubyのメタプログラミングを学びたい方

# マインスイーパーとは
> マインスイーパ（Minesweeper）は、1980年代に発明された一人用のコンピュータゲームである。ゲームの目的は地雷原から地雷を取り除くこと（地雷除去）である。マインスイーパーとも表記される。

[Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%A4%E3%83%BC%E3%83%91)より

![マインスイーパのプレイ画像](https://storage.googleapis.com/zenn-user-upload/090289cd3c22-20250122.png)

上記画像はマインスイーパプレイ画像です。基本は地雷以外のセルを全て開けることでクリアとなります。セルに書かれた数字は8近傍（上・右上・右・右下・下・左下・左・左上）に存在する地雷の数を示しています。


# 仕様
あくまで今回はオブジェクト指向の学習なのでUIには拘りません。また、今後の実装予定の機能についても考慮し、変更容易性の高い疎結合な設計を目指します。

- 地雷の目印として指定したセルに旗を立てることができる
- 地雷が開かれるとゲームオーバーになり、ゲームが終了する
- 地雷があるセル以外を全て開くとゲームクリアになり、ゲームが終了する
- 開いたセルが近傍に未開封のセルを持つ場合、近傍の地雷の数を表示する
- セルを開いたとき、近傍の地雷がないセルを自動で連続的に開く。ただし、近傍に地雷があるセルに到達した場合、そのセルで処理を停止する。

:::details スコープ外
* 一定時間経過するとゲームオーバーになる
* ユーザーがはじめに選択したセルは地雷にならない
* 全ての地雷に旗を立てるとゲームクリアになる
* 3次元のマインスイーパ
* 正多角形から構成されるマインスイーパ
* 複数の難易度
* 周囲のセルが知らせる地雷数を惑わすジャミング地雷
* 一定手数を過ぎると爆発する地雷
* 人気度の高い盤面をプレイ
* 誤った旗を立てた場合のペナルティ
* 時間経過などを考慮したスコアリング
* ゲーム記録を保持/閲覧
* パフォーマンス考慮
* メモリ考慮
:::

# 概念整理
ソフトウェアの設計において、扱う対象についての概念の整理をすることは非常に重要です。具体的には以下のステップを踏む必要があります。本ブログでもこれらを実践していきます。

- 責務を捉えて言語化する
- 責務の境界線を引く

こちらのブログが概念整理についてより詳しく記述があり、大変参考になりました。
https://note.com/naro143/n/n31d2b7f97a16

# 設計
以下は全体のクラス図になります。依存関係は黒矢印、継承は白矢印、実装は白点線矢印で表現しています。Rubyには言語としてJavaのようなインターフェースが存在しませんが、クラスがオブジェクトの振る舞いに依存している場合はインターフェースに依存しているものとします。

![Overview Game](/images/overview_minesweeper.png)

![Overview Cell](/images/overview_cell.png)

### Cellクラス
![Cell](/images/cell_class.png)

Cellクラスはセル自身の状態に対する責務を持ちます。

Cellクラスは様々なクラスから最も依存されるクラスです。そのため、**最もコアな概念であるセルの状態のみ**責務を持つよう設計しました。

Cellクラスが責務外の知識を持っている例として、セルが自身の座標についての責務を持つとします。セルが座標の存在を知っていることは**暗黙的に座標平面に存在していることに依存している**ことになります。これはセルが3次元であった場合などにはCellクラスを修正する必要があります。

**❌ 座標についての責務を持つ場合**
- `x`と`y`には座標平面への依存が存在する
```ruby:cell.rb
class Cell
  attr_accessor :x, :y

  def initialize(bomb:, x:, y:)
    @bomb = bomb
    @flag = false
    @revealed = false
    @x = x
    @y = y
  end
  ...
end
```

**🟢 全体実装**
- 状態に対する責務のみを持つ
```ruby:cell.rb
class Cell
  def initialize(bomb:)
    @bomb = bomb
    @flag = false
    @revealed = false
  end

  def bomb?
    @bomb
  end

  def flag?
    @flag
  end

  def revealed?
    @revealed
  end

  def toggle_flag
    @flag = !@flag
  end

  def reveal
    @revealed = true
  end
end

```


### CellWithNeighborsクラス
![CellWithNeighbors](/images/cell_with_neighbors_class.png)

CellWithNeighborsクラスはセル自身の状態とその近傍のセルを認知する責務を持ちます。

マインスイーパにおいて「セルの近傍」は重要な関心ごとです。状態を管理するCellクラスと近傍を管理するCellWithNeighborsクラスを分離したことで、それぞれの責務が明確になります。

![base](/images/base_interface.png)

CellWithNeighborsクラスにCellクラスの振る舞いを持たせるためにbaseに**振る舞いを委譲**させています。これにより、Cellクラスからの継承による実装と比較してCellクラスへ依存を抑えつつ、振る舞いを再利用できます。

**❌ Cellクラスの継承の場合**
- `Cell`への依存が大きくなる
- `super`により不要なインターフェースであっても暗黙的に取得してしまう
```ruby:cell_with_neighbors.rb
class CellWithNeighbors < Cell
  def initialize(bomb:, neighbors: [])
    super(bomb:)
    ...
  end
```

**🟢 baseオブジェクトへ委譲**
- `base`の振る舞いにのみ依存し、`Cell`への依存を小さくできる
- `def_delegators`による委譲によりインターフェースを明示的にできる
```ruby:cell_with_neighbors.rb
class CellWithNeighbors
  extend Forwardable

  def initialize(base:, neighbors: [])
    @base = base
    ...
  end

  def_delegators :@base, :bomb?, :flag?, :revealed?, :toggle_flag, :reveal
end
```

![neighbor](/images/neighbor_interface.png)

neighborは近傍のセルを表しています。CellWithNeighborsクラスがインスタンス変数としてneigborの配列を持っているため、クラス内で**近傍に関して座標への依存が無くなっています**。その結果、複雑になりがちなセルの自動開封をシンプルに実装することができました。

**❌ Boardクラスが自動開封の責務を持つ場合**
- 自動開封`reveal_cell(x:, y:)`の実装に座標の知識が必要
- `neighbor.coordinations(x:, y:)`で近傍の座標を都度計算する必要がある
```ruby:cell_with_neighbors.rb
class Board
  def reveal_cell(x:, y:)
    cell = grid_cells[y][x]

    cell.reveal

    return if cell.bomb?

    if cell.neighbor_bomb_cell_count.zero?
      neighbor.coordinations(x:, y:).each do |nx, ny|
        reveal_cell(x: nx, y: ny) if grid_cells[ny][nx].revealed?
      end
    end
  end
end
```


**🟢 自動開封の実装**
- 座標の知識が必要ない
- 近傍`neighbors`が初期化時に計算されている
```ruby:cell_with_neighbors.rb
class CellWithNeighbors
　...
  def reveal_with_neighbors
    reveal

    # NOTE: 選択したセルが爆弾の場合は再帰処理を終了
    return if bomb?

    if neighbor_bomb_cell_count.zero?
　　　　neighbors.each do |neighbor|
　　　　　　neighbor.reveal_with_neighbors unless neighbor.revealed?
　　　　end
    end
  end
  ...
end
```

**🟢 全体実装**
```ruby:cell_with_neighbors.rb
require 'forwardable'

class CellWithNeighbors
  extend Forwardable

  attr_reader :neighbor_bomb_cell_count

  def initialize(base:, neighbors: [])
    @base = base
    @neighbors = neighbors
    @neighbor_bomb_cell_count = count_neighbor_bomb_cell
  end

  def_delegators :@base, :bomb?, :flag?, :revealed?, :toggle_flag, :reveal

  def neighbors
    @neighbors.dup
  end

  def add_neighbor(neighbor:)
    @neighbors << neighbor
    @neighbor_bomb_cell_count += 1 if neighbor.bomb?
  end

  def reveal_with_neighbors
    reveal

    # NOTE: 選択したセルが爆弾の場合は再帰処理を終了
    return if bomb?

    if neighbor_bomb_cell_count.zero?
      neighbors.each(&:reveal_with_neighbors) unless neighbor.revealed?
    end
  end

  def count_revealed_cell
    neighbors.count(&:revealed?)
  end

  private

  def count_neighbor_bomb_cell
    neighbors.count(&:bomb?)
  end
end

```

### GridCellsクラス
![GridCells](/images/grid_cells_class.png)

![position](/images/position_interface.png)

GridCellsクラスはセルについての二次元配列のデータを保持し、それに対するインターフェースを提供する責務を持ちます。開封や旗立てなどの操作はpositionインターフェースを通じて行います。これにより、GridCellsを利用するクラスは内部が二次元配列であることを意識する必要がなくなります。

**🟢 GridCellsのインターフェース**
- 二次元配列`data`を外部から隠蔽している
- `position`を通じてセルの操作を行う
```ruby:grid_cells.rb
class GridCells
  ...
  def reveal_with_neighbors(position:)
    data[position.y][position.x].reveal_with_neighbors
  end

  def toggle_flag(position:)
    data[position.y][position.x].toggle_flag
  end

  def count_revealed_cell
    data.flatten.count(&:revealed?)
  end

  def bombed?
    data.flatten.any? { |cell| cell.bomb? && cell.revealed? }
  end

  def width
    @data.first.size
  end

  def height
    @data.size
  end
  ...
end
```

### GridCellsFactoryクラス
![GridCellsFactory](/images/overview_grid_cells_factory_class.png)


**🟢 Boardクラスで利用**
```ruby:board.rb
class Board
  def initialize(difficulty:)
    @grid_cells = grid_cells_creator(difficulty).create
  end
  ...
  def grid_cells_creator(difficulty)
    case difficulty
    when Minesweeper::EASY
      GridCellsCreators::Easy.new
    when Minesweeper::NORMAL
      GridCellsCreators::Normal.new
    when Minesweeper::HARD
      GridCellsCreators::Hard.new
    else
      raise "Invalid difficulty: #{difficulty}"
    end
  end
end
```

### Boardクラス
![Board](/images/board_class.png)

BoardクラスはGridCellsクラスの操作をラップし、盤面へのインターフェースを提供します。GridCellsクラスは頻繁に変更されることが予想されるので、Boardクラスを利用する側からGridCellsのインターフェースを隠蔽しています。

盤面操作のロジックがGridCellsに集約され、Boardクラスはシンプルな操作のみを行います。

:::details 🟢 全体実装
```ruby:board.rb
class Board
  def initialize(grid_cells:)
    @grid_cells = grid_cells
  end

  def reveal_cell(position:)
    @grid_cells.reveal_with_neighbors(position:)
  end

  def toggle_flag(position:)
    @grid_cells.toggle_flag(position:)
  end

  def count_revealed_cell
    @grid_cells.count_revealed_cell
  end

  def bombed?
    @grid_cells.bombed?
  end

  def num_empties
    @grid_cells.num_empties
  end

  # TODO: 別クラスに実装する
  def display
    print "  "

    @grid_cells.data.first.each_with_index do |row, x|
      print "#{x} "
    end

    puts

    print "  "

    @grid_cells.data.first.each do |row, x|
      print "--"
    end

    puts

    @grid_cells.data.each_with_index do |row, y|
      print "#{y}|"

      row.each do |cell|
        if cell.revealed?
          if cell.bomb?
            print "B "
          elsif cell.count_revealed_cell == cell.neighbors.size
            print "◻︎ "
          else
            print "#{cell.neighbor_bomb_cell_count} "
          end
        else
          if cell.flag?
            print "F "
          else
            print "◼︎ "
          end
        end
      end
      puts
    end
  end
end

```
:::

# 番外編 メタプログラミングとvalidation 